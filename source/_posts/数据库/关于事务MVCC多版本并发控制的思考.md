---
layout: article
title: 关于事务MVCC多版本并发控制的思考
date: 2019-04-26 21:36:38
updated: 2019-04-26 22:50:06
categories: 
  - DataBase
tags: 
  - DataBase
---

## 数据库的MVCC(Multi-Version Concurrency Control)多版本并发控制

#### 事务的隔离级别 (MyISAM不支持事务, 将隔离级别是基于事务上的, 只有InnoDB支持事务隔离级别)

1. **读未提交 Read Uncommitted** 假设A向B转账 A还没提交事务 B已经发现钱变多了 A就回滚事务 B再查看钱的时候 发现钱没有变多 这就是read uncommited 造成的**脏读**现象 出现**脏读**的**本质**其实是**操作本身修改完数据之后就立刻将锁释放掉**
2. **读已提交 Read Committed** 就是将**释放锁**的**位置**调整到**事务提交之后**, 在此事务提交之前, 其他进程或者线程是无法对该行数据进行读取的, 但这样也有**弊端**, 假设AB**同时**对**数据库****进行操作**, A**准备**查询**数据库**的同时, B正在修改**数据库, 而**A想要查的数据是B修改前的数据**, 这种现象叫做不可重复读
3. **可重复读 Repeated Read** 就是 每开始一个新的事务, **系统版本号会自动递增**, (实际上是每行记录后面保存**两个隐藏的列**来实现的, 一列是保存了**行的创建时间**, 一列是保存了**行的删除时间**), 事务开始时的系统版本号作为**事务的版本号**, 用来查询的时候比较**每行记录的版本是否相符** **(其实这是一种乐观锁)** , 然鹅即便**到了如此防御的程度**, 始终还有不完美的地方, 当两个并发事务的版本号一致的时候, 会导致幻读现象, 什么叫幻读呢, 就是一个事务可能读到另一个事务insert后的值, 无中生有(咦, 这条数据哪里来的! 我本来没有的呀! 难道我漏了??? 这么玄学的???)
4. **串行化 Serializable** 在上面的基础上, 将**事务的数据读取范围加上间隙锁,** 其他事务**不能访问或修改该范围内的数据**