---
layout: article
title: 字符串的排列
date: 2019-04-15 02:36:10
updated: 2019-04-26 22:50:06
categories:
  - 剑指OFFER
tags: 
  - 剑指OFFER
---

# 字符串的排列

> ## 题目描述
>
> 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
>
> ## 输入描述:
>
> ```
> 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
> ```



做这道题吧，既然是排列，就回忆一下排列组合的数学知识吧。

![img](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D257/sign=97158a763df33a879a6d071ff15d1018/2e2eb9389b504fc2974eb943e2dde71190ef6d66.jpg)

![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D162/sign=f68c65f4b5b7d0a27fc9009bf9ee760d/5d6034a85edf8db190ab75220e23dd54574e74ea.jpg)

如果字符串为abc，那就是A33

如果字符串为alibaba，那就是C73*C42*A22

实现了计算的全排列，看看算法应该如何实现全排列呢？

以字符串abc为例，固定住第一个字符，然后让后面两个字符交换，如图所示

![img](http://img.blog.csdn.net/20130517151143329)

> 图片来源：<http://www.cnblogs.com/cxjchen/p/3932949.html>

以编程的思维来看，假定字符串长度为**n**，则循环一般是从**0~n**遍历一遍的，那我们要如何实现交换之后**递归停止呢**？

**以abc为例：**

1. 第一个字符有abc三种可能，则第一个字符遍历3次，结束条件为遍历到最后一个字符（即只剩下一个字符）
2. 第一个字符的三种可能已经确定，我们只需考虑第二字符和第三字符，显而易见，第二字符和第三字符交换即可得到两个字符串
3. 需要注意的是，首字符固定后，第二字符与第三字符进行交换后，需要换回来，保证不影响首字符的遍历集合

**那如果是三个以上的字符呢？**

**以abcde为例：**

1. 首字符有5种可能，遍历5次，每遍历一次，都要考虑首字符后面4个字符
2. 由于首字符固定，考虑后面4个字符，同处理首字符一样
3. 相当于每一次都在处理 固定的首字符
4. 结束条件为遍历到最后一个字符

**非常明显的递归关系，不断处理首字符，从而进行交换**

![1555268158383](https://icebearice.gitee.io/uploads/1555268158383.png)

**紧接着，有重复问题，怎么处理？**

对于abb而言，由于我们是固定首字符，在交换首字符a与第二字符b，并且交换回来后，若发现第三个字符与第二字符相等，则不再进行交换

**所以，交换规则就是，从首字符开始，每个字符与后面非重复出现的字符进行交换，结束条件为遍历到最后一个字符（即只剩下一个字符），然鹅进行递归处理**

算法思路如上，可以用**方法递归**或**循环**实现吧，方法递归可能需要**处理字典序问题**，循环的话可以**提前处理字典序**，处理完后再进行循环，便不需要完事（全排列）后处理字典序

在空间上，**循环不需要递归空间**

**在时间上**，**提前处理字符串的字典序会比处理完事后生成的字符串要快一些**

代码随后补上，睡觉，要猝死咯~