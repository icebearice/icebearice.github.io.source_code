---
layout: article
title: 并发常见方法
date: 2019-05-07 16:36:03
updated: 2019-05-07 16:36:59
categories: 
  - 并发
tags:
  - 并发
---

# 并发常见方法

### sleep方法

sleep是Thread类的静态方法, 暂停当前线程的活动, 休眠指定的毫秒数, 会抛出InterruptedException异常

### run方法

Runnable是接口, 实现多线程的方式之一, 直接调用run方法, 只会执行同一线程中的任务, 而不会启动新线程. 

### start方法

调用Thread.start方法, 这个方法将创建一个执行run方法的新线程, 在底层创建新线程之后, 会执行run方法

### return方法

正常结束, 或者中断进程

### Stop方法

其他线程可以调用它终止线程, 已被弃用, 弃用的原因是 stop方法是终止当前线程所有未结束的方法, 当线程被终止时, 立即释放所有相关对象的锁, 导致对象处于与原来不一致的状态, 且无法还原

### Suspend方法

挂起一个持有一个锁的线程, 不释放锁, 该锁在回复之前都是不可用的, 很容易造成死锁

### resume方法

唤醒一个被挂起的线程, 该方法在suspend方法后调用

### 线程运行的状态

- new 新创建
- runnable 可运行 一旦启用start方法,  线程则处于runnable状态 可运行分为 
  - 正在运行
  - 没有运行 没有运行则可能是 以下三种状态的一种
    - blocked 阻塞 请求锁 得到锁后 变成可运行状态
    - waiting 等待 等待通知 被通知后 变成可运行
    - timed waiting 超时等待 等待通知 被通知或者超时后 变成可运行
- terminated 被终止 执行exits方法

### getState方法

获取一个线程的当前状态

### 被终止的线程

- 原因有两种
  - 因为run方法正常退出return而自然死亡
  - 因为一个没有捕获的异常throws终止了run方法而意外死亡
    - stop杀死一个线程的时候, 该方法抛出ThreadDeath错误对象异常, 由此杀死线程

### join方法

等待指定线程终止, 可带参数, 指等待指定毫秒数

### 守护进程

为其他线程提供服务, 比如ftp服务, 若所有进程中, 只有守护进程在运行, 虚拟机就会退出, 守护进程不应该去访问固有资源例如数据库, 因为守护进程随时可能被一个操作中断

### 竞争条件

两个或两个以上的线程需要共享同一个数据的存取, 则存在竞争条件

### 可重入锁RenntrantLock类

通过创建可重入锁的实力, 临界区的开始调用lock方法, 一般用try catch finally代码块限制临界区确保临界区的代码执行完之后, finally块需要释放锁unlock(), 可重入锁有一个对象持有数计数器, 用于锁的嵌套调用, 表明目前持有的对象数量, 当持有计数为0时, 线程释放锁

可重入锁可以有多个条件对象, 根据条件对象来让线程进入条件的等待集中

锁被释放的时候, 调用signalAll接触该条件的等待集中的所有线程的阻塞状态

若调用signal方法, 该条件会随机选择一个线程 释放其阻塞状态 这种方法有风险 如果该线程不满足条件的话  其他被阻塞的线程就永远都不会再运行了, 就造成死锁的现象了 

ReentrantLock的构造方法可以构造一个公平策略的可重入锁, 公平锁会优先选择等待时间最长的线程, 即便是这样, 如果线程调度器因为策略选择忽略这个线程, 即便这个线程等待了很长时间, 他也会被忽略, 不能确保完全公平

### Synchronized内在锁 固有锁

对象自带的内部所, 和lock不一样的是, 内部对象锁只可以有一个相关条件

用wait方法添加一个线程到等待集中, 用notifyAll/ notify接触等待线程的阻塞状态, notify同样也是随机接触一个线程, 有死锁的风险

### 死锁的场景

可重入锁或者同步对象锁 用signal或者notify随机唤醒一个线程, 导致死锁

suspend方法挂起一个线程后, suspend是不会释放锁的, 若线程试图获取同一个锁, 程序会变死锁

MySQL并发修改同一记录或封锁同一范围导致相互等待

